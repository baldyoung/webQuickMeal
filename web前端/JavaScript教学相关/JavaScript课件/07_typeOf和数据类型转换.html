<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<link rel="stylesheet" href="css/style.css">
	</head>
	<body>
		<h2>前言</h2>

		<p><strong>变量的数据类型转换</strong>：将一种数据类型转换为另外一种数据类型。</p>

		<p>通常有三种形式的类型转换：</p>

		<ul>
			<li>
				<p>转换为字符串类型</p>
			</li>
			<li>
				<p>转换为数字型</p>
			</li>
			<li>
				<p>转换为布尔型</p>
			</li>
		</ul>

		<p>你会专门把某个数据类型转换成 null 或者 undefined 吗？不会，因为这样做，没有意义。</p>

		<h2>typeof 运算符</h2>

		<blockquote>
			<p>我们先来讲一下 typeof，再讲类型转换。</p>
		</blockquote>

		<p><code>typeof()</code>表示“<strong>获取变量的数据类型</strong>”，返回的是小写，语法为：（两种写法都可以）</p>

		<pre>
// 写法1
typeof 变量;

// 写法2
typeof(变量);</pre>

		<p>typeof 这个运算符的返回结果就是变量的类型。那返回结果的类型是什么呢？是字符串。</p>

		<p><strong>返回结果</strong>：</p>

		<pre style='color:yellow; '>
| typeof 的代码写法 | 返回结果 |
| :---------------- | :-------: |
| typeof 数字 | number |
| typeof 字符串 | string |
| typeof 布尔型 | boolean |
| typeof 对象 | object |
| typeof 方法 | function |
| typeof null | object |
| typeof undefined | undefined |</pre>

		<p>备注 1：为啥 <code>typeof null</code>的返回值也是 object 呢？因为 null 代表的是<strong>空对象</strong>。</p>

		<p>备注 2：<code>typeof NaN</code>的返回值是 number，上一篇文章中讲过，NaN 是一个特殊的数字。</p>

		<p><strong>返回结果举例</strong>：</p>

		<pre>
console.log(typeof []); // 空数组的打印结果：object
console.log(typeof {}); // 空对象的打印结果：object</pre>

		<p>代码解释：这里的空数组<code>[]</code>、空对象<code>{}</code> ，为啥他们在使用 typeof 时，返回值也是 <code>object</code>呢？因为这里的 返回结果<code>object</code>指的是<strong>引用数据类型</strong>。空数组、空对象都是<strong>引用数据类型
				Object</strong>。</p>

		<p>typeof 无法区分数组，但 instanceof 可以。比如：</p>

		<pre>
console.log([] instanceof Array); // 打印结果：true
console.log({} instanceof Array); // 打印结果：false</pre>

		<p>关于 instanceof 的详细内容，以后讲对象的时候，会详细介绍。</p>

		<h2>变量的类型转换的分类</h2>

		<p>类型转换分为两种：显示类型转换、隐式类型转换。</p>

		<h3>显示类型转换</h3>

		<ul>
			<li>
				<p>toString()</p>
			</li>
			<li>
				<p>String()</p>
			</li>
			<li>
				<p>Number()</p>
			</li>
			<li>
				<p>parseInt(string)</p>
			</li>
			<li>
				<p>parseFloat(string)</p>
			</li>
			<li>
				<p>Boolean()</p>
			</li>
		</ul>

		<h3>隐式类型转换</h3>

		<ul>
			<li>
				<p>isNaN ()</p>
			</li>
			<li>
				<p>自增/自减运算符：<code>++</code>、<code>—-</code></p>
			</li>
			<li>
				<p>正号/负号：<code>+a</code>、<code>-a</code></p>
			</li>
			<li>
				<p>加号：<code>+</code></p>
			</li>
			<li>
				<p>运算符：<code>-</code>、<code>*</code>、<code>/</code></p>
			</li>
		</ul>

		<h3>隐式类型转换（特殊）</h3>

		<ul>
			<li>
				<p>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>！</code> 。非布尔值进行<strong>与或</strong>运算时，会先将其转换为布尔值，然后再运算，但运算结果是<strong>原值</strong>。具体可以看下一篇文章《运算符》。</p>
			</li>
			<li>
				<p>关系运算符：<code>&lt;</code>、<code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code>等。关系运算符，得到的运算结果都是布尔值：要么是true，要么是false。具体可以看下一篇文章《运算符》。</p>
			</li>
		</ul>

		<p>针对上面这两种类型转换，这篇文章来详细介绍。</p>

		<h2>其他的简单类型 --&gt; String</h2>

		<h3>方法一（隐式类型转换）：字符串拼接</h3>

		<p>格式：变量+"" 或者 变量+"abc"</p>

		<p>举例：</p>

		<pre>
var a = 123; // Number 类型
console.log(a + ''); // 转换成 String 类型
console.log(a + 'haha'); // 转换成 String 类型</pre>

		<p>上面的例子中，打印的结果，都是字符串类型的数据。实际上内部是调用的 String() 函数。也就是说，<code>c = c + ""</code> 等价于 <code>c = String(c)</code>。</p>

		<h3>方法二：调用 toString()方法</h3>

		<p>语法：</p>

		<p>
变量.toString()</p>

		<p>【重要】该方法<strong>不会影响到原变量</strong>，它会将转换的结果返回。当然我们还可以直接写成<code>a = a.toString()</code>，这样的话，就是直接修改原变量。</p>

		<p>注意：null 和 undefined 这两个值没有 toString()方法，所以它们不能用方法二。如果调用，会报错。</p>

		<p>另外，Number 类型的变量，在调用 toString()时，可以在方法中传递一个整数作为参数。此时它将会把数字转换为指定的进制，如果不指定则默认转换为 10 进制。例如：</p>

		<pre>
var a = 255;
//对于Number调用toString()时可以在方法中传递一个整数作为参数
//此时它将会把数字转换为指定的进制,如果不指定则默认转换为10进制
a = a.toString(2); // 转换为二进制
console.log(a); // 11111111
console.log(typeof a); // string</pre>

		<h3>方法三（强制转换）：使用 String()函数</h3>

		<p>语法：</p>

		<p>
String(变量)</p>

		<p>使用 String()函数做强制类型转换时：</p>

		<ul>
			<li>
				<p>对于 Number 和 Boolean 而言，本质上就是调用 toString()方法。</p>
			</li>
			<li>
				<p>但是对于 null 和 undefined，则不会调用 toString()方法。它会将 null 直接转换为 "null"。将 undefined 直接转换为 "undefined"。</p>
			</li>
		</ul>

		<h3>prompt()：用户的输入</h3>

		<p>我们在 JS 基础的第 01 篇里，就讲过，<code>prompt()</code>就是专门用来弹出能够让用户输入的对话框。重要的是：用户不管输入什么，都当字符串处理。</p>

		<h2>其他的数据类型 --&gt; Number 【重要】</h2>

		<h3>使用 Number() 函数</h3>

		<p><strong>情况一：字符串 --&gt; 数字</strong></p>

		<ul>
			<li>
				<p>1.如果字符串中是纯数字，则直接将其转换为数字。</p>
			</li>
			<li>
				<p>2.如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0。</p>
			</li>
			<li>
				<p>3.只要字符串中包含了其他非数字的内容（<code>小数点</code>按数字来算），则转换为 NaN。</p>
			</li>
		</ul>

		<p><strong>情况二：布尔 --&gt; 数字</strong></p>

		<ul>
			<li>
				<p>true 转成 1</p>
			</li>
			<li>
				<p>false 转成 0</p>
			</li>
		</ul>

		<p><strong>情况三：null --&gt; 数字</strong></p>

		<ul>
			<li>结果为：0</li>
		</ul>

		<p><strong>情况四：undefined --&gt; 数字</strong></p>

		<ul>
			<li>结果为：NaN</li>
		</ul>

		<p>补充：怎么理解这里的 <strong>NaN</strong> 呢？可以这样理解，使用 Number() 函数之后，<strong>如果无法转换为数字，就会转换为 NaN</strong>。</p>

		<h3>使用 parseInt()函数：字符串 -&gt; 整数</h3>

		<p><strong>parseInt()的作用是将字符串中的有效的整数内容转为数字</strong>。parse 表示“转换”，Int 表示“整数”（注意<code>Int</code>的拼写）。例如：</p>

		<pre>
parseInt("5");</pre>

		<p>得到的结果是数字 5。</p>

		<p>parseInt()的转换情况如下。</p>

		<p><strong>情况一：字符串 --&gt; 数字</strong></p>

		<ul>
			<li>
				<p>1.<strong>只保留字符串最开头的数字</strong>，后面的中文自动消失。</p>
			</li>
			<li>
				<p>2.如果字符串不是以数字开头，则转换为 NaN。</p>
			</li>
			<li>
				<p>3.如果字符串是一个空串或者是一个全是空格的字符串，转换时会报错。</p>
			</li>
		</ul>

		<p><strong>情况二：Boolean --&gt; 数字</strong></p>

		<ul>
			<li>结果为：NaN</li>
		</ul>

		<p><strong>情况三：Null --&gt; 数字</strong></p>

		<ul>
			<li>结果为：NaN</li>
		</ul>

		<p><strong>情况四：Undefined --&gt; 数字</strong></p>

		<ul>
			<li>结果为：NaN</li>
		</ul>

		<p>Number() 函数和 parseInt() 函数的区别：</p>

		<p>就拿<code>Number(true)</code> 和 <code>parseInt(true)/parseFloat(true)</code>来举例，二者在使用时，是有区别的：</p>

		<ul>
			<li>
				<p>Number(true) ：千方百计地想转换为数字。</p>
			</li>
			<li>
				<p>parseInt(true)/parseFloat(true) ：先转为字符串，再提取出最前面的数字部分；没提取出来，那就返回 NaN。</p>
			</li>
		</ul>

		<p><strong>parseInt()具有以下特性</strong>：</p>

		<p>（1）<strong>只保留字符串最开头的数字</strong>，后面的中文自动消失。例如：</p>

		<pre>
console.log(parseInt("2017在公众号上写了6篇文章")); //打印结果：2017
console.log(parseInt("2017.01在公众号上写了6篇文章")); //打印结果仍是：2017 （说明只会取整数）
console.log(parseInt("aaa2017.01在公众号上写了6篇文章")); //打印结果：NaN （因为不是以数字开头）</pre>

		<p>（2）如果对<strong>非 String</strong>使用 parseInt()或 parseFloat()，它会<strong>先将其转换为 String</strong> 然后再操作。【重要】</p>

		<p>比如：</p>

		<pre>
var a = 168.23;
console.log(parseInt(a)); //打印结果：168 （因为是先将 a 转为字符串"168.23"，然后然后再操作）
var b = true;
console.log(parseInt(b)); //打印结果：NaN （因为是先将 b 转为字符串"true"，然后然后再操作）
var c = null;
console.log(parseInt(c)); //打印结果：NaN （因为是先将 c 转为字符串"null"，然后然后再操作）
var d = undefined;
console.log(parseInt(d)); //打印结果：NaN （因为是先将 d 转为字符串"undefined"，然后然后再操作）</pre>

		<p>（3）自动带有截断小数的功能：<strong>取整，不四舍五入</strong>。</p>

		<p>例 1：</p>

		<pre>
var a = parseInt(5.8) + parseInt(4.7);
console.log(a);</pre>

		<p>打印结果：</p>

		<pre>
9</pre>

		<p>例 2：</p>

		<pre>
var a = parseInt(5.8 + 4.7);
console.log(a);</pre>

		<p>打印结果：</p>

		<pre>
10</pre>

		<p>（4）带两个参数时，表示在转换时，包含了进制转换。</p>

		<p>代码举例：</p>

		<pre>
var a = '110';
var num = parseInt(a, 16); // 【重要】将 a 当成 十六进制 来看待，转换成 十进制 的 num
console.log(num);</pre>

		<p>打印结果：</p>

		<pre>
272</pre>

		<p>如果你对打印结果感到震惊，请仔细看上面的代码注释。就是说，无论 parseInt() 里面的进制参数是多少，最终的转换结果是十进制。</p>

		<p>我们继续来看下面的代码，打印结果是多少。</p>

		<pre>
var a = '5';
var num = parseInt(a, 2); // 将 a 当成 二进制 来看待，转换成 十进制 的 num
console.log(num); // 打印结果：NaN。因为 二进制中没有 5 这个数，转换失败。</pre>

		<h3>parseFloat()函数：字符串 --&gt; 浮点数（小数）</h3>

		<p>parseFloat()的作用是：将字符串转换为<strong>浮点数</strong>。</p>

		<p>parseFloat()和 parseInt()的作用类似，不同的是，parseFloat()可以获得有效的小数部分。</p>

		<p>代码举例：</p>

		<pre>
var a = '123.456.789px';
console.log(parseFloat(a)); // 打印结果：123.456</pre>

		<p>parseFloat() 的几个特性，可以参照 parseInt()。</p>

		<h2>转换为 Boolean</h2>

		<p>其他的数据类型都可以转换为 Boolean类型。情况如下：</p>

		<ul>
			<li>
				<p>情况一：数字 --&gt; 布尔。除了 0 和 NaN，其余的都是 true。也就是说，<code>Boolean(NaN)</code>的结果是 false。</p>
			</li>
			<li>
				<p>情况二：字符串 ---&gt; 布尔。除了空串，其余的都是 true。全是空格的字符串，转换结果也是 true。字符串<code>'0'</code>的转换结果也是 true。</p>
			</li>
			<li>
				<p>情况三：null 和 undefined 都会转换为 false。</p>
			</li>
			<li>
				<p>情况四：引用数据类型会转换为 true。注意，空数组<code>[]</code>和空对象<code>{}</code>，<strong>转换结果也是 true</strong>，这个一点，很多人都不知道。</p>
			</li>
		</ul>

		<p>PS：转换为 Boolean 的这几种情况，<strong>很重要</strong>，开发中会经常用到。</p>

		<p><strong>1、隐式转换为 Boolean 类型</strong>：</p>

		<p>当非 Boolean 类型的数值和 Boolean类型的数值做比较时，会先把前者进行隐式转换为 Boolean类型，然后再做比较。举例如下：</p>

		<pre>
console.log(1 == true); // 打印结果：true
console.log(0 == true); // 打印结果：false</pre>

		<p><strong>2、显式转换为 Boolean 类型</strong>：</p>

		<p>方法1：使用 <code>!!</code>可以显式转换为 Boolean 类型。比如 <code>!!3</code>的结果是true。</p>

		<p>方法2：使用 Boolean()函数可以显式转换为 Boolean 类型。</p>

		<h2>知识补充：其他进制的数字</h2>

		<ul>
			<li>
				<p>16 进制的数字，以<code>0x</code>开头</p>
			</li>
			<li>
				<p>8 进制的数字，以<code>0</code>开头</p>
			</li>
			<li>
				<p>2 进制的数字，<code>0b</code>开头（不是所有的浏览器都支持：chrome 和火狐支持，IE 不支持）</p>
			</li>
		</ul>

		<p>比如<code>070</code>这个字符串，如果我调用 parseInt()转成数字时，有些浏览器会当成 8 进制解析，有些会当成 10 进制解析。</p>

		<p>所以，比较建议的做法是：可以在 parseInt()中传递第二个参数，来指定当前数字的进制。例如：</p>

		<pre>
var a = "070";
a = parseInt(a, 8); //将 070 当成八进制来看待，转换结果为十进制。
console.log(a); // 打印结果：56。这个地方要好好理解。</pre>

		<h2>隐式类型转换</h2>

		<p>重点：<strong>隐式类型转换，内部调用的都是显式类型的方法</strong>。下面来详细介绍。</p>

		<h3>isNaN() 函数</h3>

		<p>语法：</p>

		<p>
				isNaN(参数);
		</p>

		<p>解释：判断指定的参数是否为 NaN（非数字类型），返回结果为 Boolean 类型。也就是说：<strong>任何不能被转换为数值的参数，都会让这个函数返回 true</strong>。</p>

		<p><strong>执行过程</strong>：</p>

		<p>（1）先调用<code>Number(参数)</code>函数；</p>

		<p>（2）然后将<code>Number(参数)</code>的返回结果和<code>NaN</code>进行比较。</p>

		<p>代码举例：</p>

		<pre>
console.log(isNaN('123')); // 返回结果：false。
console.log(isNaN('abc')); // 返回结果：true。因为 Number('abc') 的返回结果是 NaN
console.log(isNaN(null)); // 返回结果：false
console.log(isNaN(undefined)); // 返回结果：true
console.log(isNaN(NaN)); // 返回结果：true</pre>

		<h3>自增/自减运算符：<code>++</code>、<code>—-</code></h3>

		<p><strong>举例 1</strong>：</p>

		<pre>
var a = "666";
a++;
console.log(typeof a); // 打印结果： number
console.log(a); // 打印结果：667</pre>

		<p>执行过程：</p>

		<p>（1）先调用<code>Number(参数)</code>函数；</p>

		<p>（2）然后将<code>Number(参数)</code>的返回结果进行 加 1 操作。</p>

		<p><strong>举例 2</strong>：</p>

		<pre>
var a = 'abc';
a++;
console.log(typeof a); // 打印结果：number
console.log(a); // 打印结果：NaN。因为 Number('abc')的结果为 NaN，再自增后，结果依然是 NaN</pre>

		<h3>正号/负号：<code>+a</code>、<code>-a</code></h3>

		<blockquote>
			<p>注意，这里说的是正号/负号，不是加号/减号。</p>
		</blockquote>

		<p>任何值做<code>+a</code>、<code>-a</code>、<code>/a</code>运算时，运算结果都会自动转换为 Number 类型。 内部调用的是 Number() 函数。</p>

		<p><strong>举例</strong>：</p>

		<pre>
var a = '666';
var b = +a;
console.log(typeof a); // 打印结果：string。说明 a 的数据类型保持不变。
console.log(a); // 打印结果：666
console.log(typeof b); // 打印结果：number。说明 b 的数据类型发生了变化。
console.log(b); // 打印结果：666</pre>

		<h3>加号：<code>+</code></h3>

		<p><strong>情况一</strong>：字符串 + 数字</p>

		<ul>
			<li>当加号的两边，只要有一个是字符串的时候，就会调用 String() 函数将数字转为字符串，然后再计算。导致最终的运算结果是字符串。</li>
		</ul>

		<p><strong>情况二</strong>：Boolean + 数字</p>

		<ul>
			<li>Boolean 型和数字型相加时， true 按 1 来算 ，false 按 0 来算。这里其实是先调 Number() 函数，将 Boolean 类型转换为 Number类型，然后再和 数字相加。</li>
		</ul>

		<p><strong>情况三</strong>： null + 数字</p>

		<ul>
			<li>等价于：0 + 数字</li>
		</ul>

		<p><strong>情况四</strong>： undefined + 数字</p>

		<ul>
			<li>计算结果：NaN</li>
		</ul>

		<h3>运算符：<code>-</code>、<code>*</code>、<code>/</code></h3>

		<p>1、任何非 Number 类型的值做<code>-</code>、<code>*</code>、<code>/</code>运算时，会将这些值转换为Number然后再运算(内部调用的是 Number() 函数），运算结果是
			Number 类型。（注：<code>任何值 + 字符串</code>是特例，运算结果是字符串）</p>

		<p>比如：</p>

		<pre>
result1 = true + 1; // 2 = 1+ 1
result2 = true + false; // 1 = 1+ 0
result3 = 1 + null; // 1 = 1+ 0
result4 = 100 - '1' // 99</pre>

		<p>2、任何的值和字符串做加法运算，都会先转换为字符串，然后再做拼串操作。</p>

		<p>比如：</p>

		<pre>
result1 = 1 + 2 + '3' // 33
result2 = '1' + 2 + 3; // 123</pre>

		<p>3、任何值和NaN做运算的结果都是NaN。</p>

		
	</body>
</html>
